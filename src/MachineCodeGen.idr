module MachineCodeGen

import AST
import Data.List
import Instruction
import Machine

--Exceptions that can be generated by code generation.
public export
data CodeGenerationException =
    InvalidExpressionException String AST

--Generate code for a numeric constant.
public export total
genLoadConstant : AST -> Either CodeGenerationException (List Instruction)
genLoadConstant (NumericConst i _) =
    Right [IMM (fromInteger i)]
genLoadConstant a = Left $ InvalidExpressionException "Expecting NumericConst" a

--Generate code for an add expression.
public export total
genAddExpr : List Instruction -> List Instruction
            -> Either CodeGenerationException (List Instruction)
genAddExpr x y =
    Right (y ++ [PUSH] ++ x ++ [ADD])

--Generate code for a sub expression.
public export total
genSubExpr : List Instruction -> List Instruction
            -> Either CodeGenerationException (List Instruction)
genSubExpr x y =
    Right (y ++ [PUSH] ++ x ++ [SUB])

--Generate code for a mul expression.
public export total
genMulExpr : List Instruction -> List Instruction
            -> Either CodeGenerationException (List Instruction)
genMulExpr x y =
    Right (y ++ [PUSH] ++ x ++ [MUL])

--Generate code for an and expression.
public export total
genAndExpr : List Instruction -> List Instruction
            -> Either CodeGenerationException (List Instruction)
genAndExpr x y =
    Right (y ++ [PUSH] ++ x ++ [AND])

--Generate code for an or expression.
public export total
genOrExpr : List Instruction -> List Instruction
            -> Either CodeGenerationException (List Instruction)
genOrExpr x y =
    Right (y ++ [PUSH] ++ x ++ [OR])

--Generate Machine Instructions for a given reducible expression.
public export total
genReduceExpr : AST -> Either CodeGenerationException (List Instruction)
--Reduce a numeric constant.
genReduceExpr (NumericConst a t) =
    genLoadConstant $ NumericConst a t
--A return expression is essentially a NOP, so unfold it.
genReduceExpr (ReturnExpr a) =
    genReduceExpr a
--Reduce an add expression to an addition of its child nodes.
genReduceExpr (AddExpr x y) =
    join $ pure genAddExpr <*> genReduceExpr x <*> genReduceExpr y
--Reduce a sub expression to a subtraction of its child nodes.
genReduceExpr (SubExpr x y) =
    join $ pure genSubExpr <*> genReduceExpr x <*> genReduceExpr y
--Reduce a mul expression to a multiplication of its child nodes.
genReduceExpr (MulExpr x y) =
    join $ pure genMulExpr <*> genReduceExpr x <*> genReduceExpr y
--Reduce an and expression to a logical and of its child nodes.
genReduceExpr (AndExpr x y) =
    join $ pure genAndExpr <*> genReduceExpr x <*> genReduceExpr y
--Reduce an or expression to a logical or of its child nodes.
genReduceExpr (OrExpr x y) =
    join $ pure genOrExpr <*> genReduceExpr x <*> genReduceExpr y
--Unknown mapping from the given AST to a reducible expression.
genReduceExpr a =
    Left $ InvalidExpressionException "Expecting reducible expression" a

--helper for proofs below to convert between code generation and machine
--evaluation environments.
total
codeGenToMachineHelper : Either CodeGenerationException (List Instruction)
                       -> Either MachineException (List Instruction)
codeGenToMachineHelper (Right a) = Right a
codeGenToMachineHelper (Left a) = Left (NotImplementedException "x")

--proof that evaluating the loading of a constant results in that constant.
total
genReduceConstantEvalSpec : (c : Integer)
                            -> codeGenToMachineHelper
                                    (genReduceExpr (NumericConst c Nothing))
                                        >>= (\ins => callFunction ins [])
                                = Right (fromInteger c)
genReduceConstantEvalSpec c = Refl

--proof that evaluating the addition of two constants results in the same
--expression in Idris.
total
genReduceAddEvalSpec : (x, y : Integer)
                        -> codeGenToMachineHelper
                                (genReduceExpr
                                    (AddExpr
                                        (NumericConst x Nothing)
                                        (NumericConst y Nothing)))
                                >>= (\ins => callFunction ins [])
                            = Right
                                (prim__addB64 (fromInteger x) (fromInteger y))
genReduceAddEvalSpec x y = Refl

--proof that evaluating the subtraction of two constants results in the same
--expression in Idris.
total
genReduceSubEvalSpec : (x, y : Integer)
                        -> codeGenToMachineHelper
                                (genReduceExpr
                                    (SubExpr
                                        (NumericConst x Nothing)
                                        (NumericConst y Nothing)))
                                >>= (\ins => callFunction ins [])
                            = Right
                                (prim__subB64 (fromInteger x) (fromInteger y))
genReduceSubEvalSpec x y = Refl

--proof that evaluating the multiplication of two constants results in the same
--expression in Idris.
total
genReduceMulEvalSpec : (x, y : Integer)
                        -> codeGenToMachineHelper
                                (genReduceExpr
                                    (MulExpr
                                        (NumericConst x Nothing)
                                        (NumericConst y Nothing)))
                                >>= (\ins => callFunction ins [])
                            = Right
                                (prim__mulB64 (fromInteger x) (fromInteger y))
genReduceMulEvalSpec x y = Refl

--proof that evaluating the logical AND of two constants results in the same
--expression in Idris.
total
genReduceAndEvalSpec : (x, y : Integer)
                        -> codeGenToMachineHelper
                                (genReduceExpr
                                    (AndExpr
                                        (NumericConst x Nothing)
                                        (NumericConst y Nothing)))
                                >>= (\ins => callFunction ins [])
                            = Right
                                (prim__andB64 (fromInteger x) (fromInteger y))
genReduceAndEvalSpec x y = Refl

--proof that evaluating the logical OR of two constants results in the same
--expression in Idris.
total
genReduceOrEvalSpec : (x, y : Integer)
                        -> codeGenToMachineHelper
                                (genReduceExpr
                                    (OrExpr
                                        (NumericConst x Nothing)
                                        (NumericConst y Nothing)))
                                >>= (\ins => callFunction ins [])
                            = Right
                                (prim__orB64 (fromInteger x) (fromInteger y))
genReduceOrEvalSpec x y = Refl
